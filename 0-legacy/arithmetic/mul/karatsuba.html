<!DOCTYPE html><html lang="en"><head><title>0-legacy/arithmetic/mul/karatsuba</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../"><meta name="groc-document-path" content="0-legacy/arithmetic/mul/karatsuba"><meta name="groc-project-path" content="js/src/0-legacy/arithmetic/mul/karatsuba.js"><meta name="groc-github-url" content="https://github.com/aureooms/js-integer-big-endian"><link rel="stylesheet" type="text/css" media="all" href="../../../assets/style.css"><script type="text/javascript" src="../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/aureooms/js-integer-big-endian/blob/master/js/src/0-legacy/arithmetic/mul/karatsuba.js">js/src/0-legacy/arithmetic/mul/karatsuba.js</a></div></div><div id="document"><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>/!\ BLOCK MULTIPLICATION RESULT MUST HOLD IN THE JAVASCRIPT NUMBER TYPE (DOUBLE i.e. 53 bits)</p>
<p>Parameters:</p>
<ul>
<li><p><strong>add must be a function.</strong><br/>(addition algorithm)</p>
</li>
<li><p><strong>sub must be a function.</strong><br/>(subtraction algorithm)</p>
</li>
<li><p><strong>mul must be a function.</strong><br/>(multiplication algorithm)</p>
</li>
<li><p><strong>copy must be a function.</strong><br/>(copy algorithm)</p>
</li>
<li><p><strong>calloc must be a function.</strong><br/>(array allocator)</p>
</li>
<li><p><strong>r must be an uint.</strong><br/>(base (radix) EXPLANATION ########### We consider the numbers a and b, both of size N = 2n. We divide a and b into their lower and upper parts. a = a1 r^{n} + a0 (1) b = b1 r^{n} + b0 (2) We express the product of a and b using their lower and upper parts. a b = (a1 r^{n} + a0) (b1 r^{n} + b0) (3) = a1 b1 r^{2n} + (a1 b0 + a0 b1) r^{n} + a0 b0 (4) This gives us 4 multiplications with operands of size n. Using a simple trick, we can reduce this computation to 3 multiplications. We give the 3 terms of (4) the names z0, z1 and z2. z2 = a1 b1 z1 = a1 b0 + a0 b1 z0 = a0 b0 a b = z2 r^{2n} + z1 r^{n} + z0 We then express z1 using z0, z2 and one additional multiplication. (a1 + a0)(b1 + b0) = a1 b1 + a0 b0 + (a1 b0 + a0 b1) = z2 + z0 + z1 z1 = (a1 + a0)(b1 + b0) - z2 - z0 AN ANOTHER WAY AROUND (not used here) (a1 - a0)(b1 - b0) = (a1 b1 + a0 b0) - (a1 b0 + a0 b1) (a0 - a1)(b1 - b0) = (a1 b0 + a0 b1) - (a1 b1 + a0 b0) a b = (r^{2n} + r^{n})a1 b1 + r^{n}(a0 - a1)(b1 - b0) + (r^{n} + 1)a0 b0 This algorithm is a generalization of the Toom-Cook algorithm, when m = n = 2. For further reference, see - <a href="http://en.wikipedia.org/wiki/Karatsuba_algorithm">http://en.wikipedia.org/wiki/Karatsuba_algorithm</a> - <a href="http://en.wikipedia.org/wiki/Toom–Cook_multiplication">http://en.wikipedia.org/wiki/Toom–Cook_multiplication</a>)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> bkaratsuba_t = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">add, sub, mul, calloc, mov, r, wrap</span>)</span>{</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Multiply two big endian arrays using karatsuba algorithm,
i &gt;= j, k &gt;= 2 * i</p>
<p>Parameters:</p>
<ul>
<li><p><strong>a must be an array.</strong><br/>(first operand)</p>
</li>
<li><p><strong>ai must be an int.</strong><br/>(a left)</p>
</li>
<li><p><strong>aj must be an int.</strong><br/>(a right)</p>
</li>
<li><p><strong>b must be an array.</strong><br/>(second operand)</p>
</li>
<li><p><strong>bi must be an int.</strong><br/>(b left)</p>
</li>
<li><p><strong>bj must be an int.</strong><br/>(b right)</p>
</li>
<li><p><strong>c must be an array.</strong><br/>(result, must be 0 initialized)</p>
</li>
<li><p><strong>ci must be an int.</strong><br/>(c left)</p>
</li>
<li><p><strong>cj must be an int.</strong><br/>(c right)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> karatsuba = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, ai, aj, b, bi, bj, c, ci, cj</span>)</span>{

		<span class="hljs-keyword">var</span> z0, z2, t1, t2, t3, n, I, N, N_, i_, j_, i, j, k;

		i = aj - ai;
		j = bj - bi;
		k = cj - ci;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>EMPTY CASE</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-number">0</span> || j &lt;= <span class="hljs-number">0</span> || k &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>BASE CASE i = j = 1</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span>) {

			z0 = a[ai] * b[bi];
			c[cj-<span class="hljs-number">1</span>] = z0 % r;

			<span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">1</span>) {
				c[cj-<span class="hljs-number">2</span>] = (z0 - c[cj-<span class="hljs-number">1</span>]) / r;
			}

		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>RECURSION</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">else</span>{
			n  = <span class="hljs-built_in">Math</span>.ceil(i / <span class="hljs-number">2</span>);
			I  = i + j;
			N  = <span class="hljs-number">2</span> * n;
			N_ = I - N;
			i_ = aj - n;
			j_ = <span class="hljs-built_in">Math</span>.max(bi, bj - n);

			t1 = calloc(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// + 1 to handle addition overflows</span>
			t2 = calloc(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// and guarantee reducing k for the</span>
			t3 = calloc(N + <span class="hljs-number">1</span>); <span class="hljs-comment">// recursive calls</span>
			z2 = calloc(N_);
			z0 = calloc(N);
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>RECURSIVE CALLS</p></div></div><div class="code"><div class="wrapper">			mul(a, ai, i_, b, bi, j_, z2, <span class="hljs-number">0</span>, N_);            <span class="hljs-comment">// z2 = a1.b1</span>
			mul(a, i_, aj, b, j_, bj, z0, <span class="hljs-number">0</span>, N);             <span class="hljs-comment">// z0 = a0.b0</span>
			add(a, i_, aj, a, ai, i_, t1, <span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>);         <span class="hljs-comment">// (a0 + a1)</span>
			add(b, bi, j_, b, j_, bj, t2, <span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>);         <span class="hljs-comment">// (b1 + b0)</span>
			mul(t1, <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>, t2, <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>, t3, <span class="hljs-number">1</span>, N + <span class="hljs-number">1</span>);   <span class="hljs-comment">// (a0 + a1)(b1 + b0)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>BUILD OUTPUT</p></div></div><div class="code"><div class="wrapper">			mov(z2, <span class="hljs-number">0</span>, N_, c, cj - I);                       <span class="hljs-comment">// + z2 . r^{2n}</span>
			mov(z0, <span class="hljs-number">0</span>, N , c, cj - N);                       <span class="hljs-comment">// + z0</span>

			<span class="hljs-keyword">if</span> (t1[<span class="hljs-number">0</span>]) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>overflow on t1, add t2 . r^{n}</p></div></div><div class="code"><div class="wrapper">				add(t3, <span class="hljs-number">0</span>, N + <span class="hljs-number">1</span> - n, t2, <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>, t3, <span class="hljs-number">0</span>, N + <span class="hljs-number">1</span> - n);
			}

			<span class="hljs-keyword">if</span> (t2[<span class="hljs-number">0</span>]) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>overflow on t2, add t1 . r^{n}</p></div></div><div class="code"><div class="wrapper">				add(t3, <span class="hljs-number">0</span>, N + <span class="hljs-number">1</span> - n, t1, <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>, t3, <span class="hljs-number">0</span>, N + <span class="hljs-number">1</span> - n);
			}

			<span class="hljs-keyword">if</span> (t1[<span class="hljs-number">0</span>] &amp;&amp; t2[<span class="hljs-number">0</span>]) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>overflow on t1 and t2, add 1 . r^{n+1}</p></div></div><div class="code"><div class="wrapper">				add(t3, <span class="hljs-number">0</span>, N - n, t1, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, t3, <span class="hljs-number">0</span>, N - n);
			}

			add(c, ci, cj - n, t3, <span class="hljs-number">0</span>, N + <span class="hljs-number">1</span>, c, ci, cj - n); <span class="hljs-comment">// + (a0 + a1)(b1 + b0) . r^{n}</span>
			sub(c, ci, cj - n, z2, <span class="hljs-number">0</span>, N_, c, ci, cj - n);    <span class="hljs-comment">// - z2 . r^{n}</span>
			sub(c, ci, cj - n, z0, <span class="hljs-number">0</span>, N, c, ci, cj - n);     <span class="hljs-comment">// - z1 . r^{n}</span>
		}

	};

	<span class="hljs-keyword">if</span> (wrap !== <span class="hljs-literal">undefined</span>) karatsuba = wrap(karatsuba);
	<span class="hljs-keyword">if</span> (mul === <span class="hljs-literal">undefined</span>) mul = karatsuba;

	<span class="hljs-keyword">return</span> karatsuba;

};


exports.bkaratsuba_t = bkaratsuba_t;</div></div></div></div></body></html>